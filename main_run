#!/usr/bin/python

##########################
### Commandline Driver ###
##########################

import numpy as np
import scipy as sp
import pandas as pd
import os, sys
import matplotlib.pyplot as plt
import seaborn as sns

from electrolyze.utilities import fit_model, pearson, featurize, test_error, bayesian_optimize


##### 1. Import Data #####

cwd = os.getcwd()
df_m = pd.read_csv(cwd+'/data/measurements.csv')
df_f = pd.read_csv(cwd+'/data/formulations.csv')

# Ensure that all mass fractions of all ingredients add up to 1
ingredients = list(df_f.drop(columns='Formulation').columns)
if all(df_f[ingredients].sum(axis=1).round(10) == 1.0):
    print('All mass fractions add up to 1')
else:
    raise ValueError('Some mass fractions do not add up to 1')

df_all = pd.concat([df_f, df_m], axis=1) # combine into one df 
df_all = df_all.loc[:,~df_all.columns.duplicated()] # remove duplicate column

column_names = df_all.columns


##### 2. Fit Model #####

from sklearn.model_selection import GridSearchCV
from sklearn.inspection import partial_dependence, plot_partial_dependence
from sklearn.gaussian_process import GaussianProcessRegressor

# Input parameters
target = 'Measurement-3'
drop = 'Additive-B'
features = df_all.columns.drop([drop,'Measurement-1','Measurement-2','Measurement-3','Formulation'])
test_size = 0.25 # for test-train splitting
n_trials = 100 # number of fitting repetitions

parameters = {'alpha':[10**i for i in range(-10,3)]}
GPReg = GaussianProcessRegressor()
GPRegGS = GridSearchCV(GPReg,parameters,cv=5) # search for optimal alpha value    

# Fit models and select the best trained one
estimators = [GPRegGS] # list of model types to try
best_model = fit_model(estimators,df_all,features,target,test_size,n_trials) # train on target Measurement-3
model_m1 = fit_model(estimators,df_all,features,'Measurement-1',test_size,n_trials) # train on Measurement-1
model_m2 = fit_model(estimators,df_all,features,'Measurement-2',test_size,n_trials) # train on Measurement-2


# Plot partial dependences
index = [i for i in range(len(features))]
fig, ax = plt.subplots(figsize=(20, 6))
plot_partial_dependence(best_model, df_all[features], index, features, target, n_cols=8, ax=ax)



##### 3.Bayesian optimization over the best model to maximize cycle life #####

def objective_function(X):
    predicted_cycle = best_model.predict(X)[0]
    return -predicted_cycle # negative cycles to be MINIMIZED

# Stop conditions
max_time  = 1500
max_iter  = 100
tolerance = 1e-5 

# Bounds for each component mass fractions
bounds = [{'name': 'SaltA', 'type': 'continuous', 'domain': (0,1)},
          {'name': 'SaltB', 'type': 'continuous', 'domain': (0,1)},
          {'name': 'SaltC', 'type': 'continuous', 'domain': (0,1)},
          {'name': 'SolventA', 'type': 'continuous', 'domain': (0,1)},
          {'name': 'SolventB', 'type': 'continuous', 'domain': (0,1)},
          {'name': 'SolventC', 'type': 'continuous', 'domain': (0,1)},
          {'name': 'AdditiveA', 'type': 'continuous', 'domain': (0,1)}
         ]

# These constraints force the compositions to almost add up to 1 
constraints = [{'name': 'constr_1', 'constraint': '0.9 - np.sum(x,axis=1)'},
               {'name': 'constr_2', 'constraint': 'np.sum(x,axis=1) - 1.0'}]

optimizer = bayesian_optimize(objective_function,bounds,constraints,max_time,max_iter,tolerance)

optimizer.plot_convergence()



##### 4. Recommend Best Compositions

# Select best compositions
n_rec = 10
index = np.argsort(optimizer.Y.flatten())[range(n_rec)]

recommended_compositions = optimizer.X[index]
recommended_targets = -optimizer.Y.flatten()[index]
formula_name = ['F_pred-{}'.format(i) for i in range(n_rec)]

print('Top {} predicted number of cycles: \n {}'.format(n_rec,recommended_targets))

# Create prediction dataframe -  don't forget to add back the dropped component (Additive-B)
last_component = np.array([1 - recommended_compositions.sum(axis=1)]).T
recommended_compositions_all = np.append(recommended_compositions,last_component,axis=1)

measurement1_pred = model_m1.predict(recommended_compositions)
measurement2_pred = model_m2.predict(recommended_compositions)

file_name = 'my_recommendation.csv'
df_prediction = pd.DataFrame(index=index, columns=column_names)
df_prediction[ingredients] = recommended_compositions_all
df_prediction['Measurement-3'] = recommended_targets
df_prediction['Measurement-2'] = measurement2_pred
df_prediction['Measurement-1'] = measurement1_pred
df_prediction['Formulation'] = formula_name
df_prediction.reset_index(inplace=True,drop=True)
df_prediction.to_csv('results/{}'.format(file_name))
